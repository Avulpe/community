const downloadGitRepo = require('download-git-repo');
const zipFolder = require('zip-folder');
const randomstring = require('randomstring');
const Gcs = require('@google-cloud/storage');
const google = require('googleapis');
const crypto = require('crypto');

/*
 * config.json contain all the required information for code running:
 *
 * url: GitHub url to the function that has to be deployed automatically,
 *    e.g. https://github.com/Avulpe/GCF_auto-deployer/blob/master/index.js
 * projectName: Google Cloud project name. E.g. my-project-12345
 * stageBucketName: Name of Google Cloud Storage bucket in which source code
 *    will be stored, e.g. a-tutorial
 * location: region in which the function runs, e.g. us-central1
 * functionName: name of the function which will be auto-deployed, e.g. helloHttp
 */
const config = require('./config.json');

/**
 * Clone the github repository.
 *
 * @param {string} filePath The full path to the directory that has to be archived.
 * @param {Object} reqObject parsed body of the github notification.
 * @param {Object} res Cloud Function response context.
 */
function downloadRepo (filePath, reqObject, res) {
  var user = reqObject.repository.owner.name;
  var repoName = reqObject.repository.name;
  downloadGitRepo (user + '/' + repoName, '/tmp/' + repoName, function(err) {
    if (err) {
      console.log('Error in downloading the %s repository: %s', repoName, err);
    } else {
      console.log('Success download of the %s repository', repoName);
      zipDir(filePath, reqObject, res);
    }
  });
}

/**
 * Zip the function's directory.
 *
 * @param {string} filePath The full path to the directory that has to be archived.
 * @param {Object} reqObject parsed body of the github notification.
 * @param {Object} res Cloud Function response context.
 */
function zipDir (filePath, reqObject, res) {
  // The autogenerated random name for the zip file.
  var archiveName = randomstring.generate(13) + '.zip';
  zipFolder('/' + filePath, '/tmp/' + archiveName, function(err) {
    if (err) {
      console.log('Error zipping %s into %s: %s', filePath, archiveName, err);
    } else {
      console.log('Success zipping %s into %s', filePath, archiveName);
      uploadToGoogleStorage(archiveName, reqObject, res);
    }
  });
}

/**
 * Upload the archive to Google Cloud Storage.
 *
 * @param {string} fileToSend The name of the file that has to be uploaded on the google storage.
 * @param {Object} reqObject parsed body of the github notification.
 * @param {Object} res Cloud Function response context.
 */
function uploadToGoogleStorage (fileToSend, reqObject, res) {
  var gcs = Gcs();

  // Reference to the desired bucket.
  var bucket = gcs.bucket(config.stageBucket);
  // Upload the local zip file in your bucket.
  bucket.upload('/tmp/' + fileToSend, function(err, file) {
    if (err) {
      console.log(
          'Error uploading the archive to google cloude storage: %s', err);
    } else {
      console.log('Success uploading the archive to google cloude storage');
      for (var i in config.deployments) {
        var deployment = config.deployments[i];
        if (deployment.path.includes(reqObject.repository.name)) {
          deployFunction(
              process.env.GCLOUD_PROJECT, config.stageBucket, deployment.functionName,
              config.location, fileToSend, reqObject, res);
        }
      }
    }
  });
}

/** Deploy the function.
 *
 * @param {string} projectName The name of the project.
 * @param {string} stageBucket The name of the bucket.
 * @param {string} functionName The name of the function.
 * @param {string} functionLocation The name of the function's location. Eg: 'us-central1'
 * @param {string} archiveName The name of the .zip file.
 * @param {Object} reqObject parsed body of the github notification.
 * @param {Object} res Cloud Function response context.
 */
function deployFunction (
    projectName, stageBucket, functionName, functionLocation, archiveName, reqObject,
    res) {
  google.auth.getApplicationDefault(function (err, authClient, projectId) {
    if (err) {
      throw err;
    }

    // The createScopedRequired method returns true when running on GAE or a
    // local developer machine. In that case, the desired scopes must be passed
    // in manually. When the code is running in GCE or a Managed VM, the scopes
    // are pulled from the GCE metadata server. See
    // https://cloud.google.com/compute/docs/authentication for more
    // information.
    if (authClient.createScopedRequired && authClient.createScopedRequired()) {
      // Scopes can be specified either as an array or as a single,
      // space-delimited string.
      authClient = authClient.createScoped(
          ['https://www.googleapis.com/auth/cloud-platform']);
    }
    var gcf = google.cloudfunctions({version: 'v1beta2', auth: authClient});
    var createRequest = {
      resource: {
        sourceArchiveUrl: 'gs://' + stageBucket + '/' + archiveName,
        name: 'projects/' + projectName + '/locations/' + functionLocation +
            '/functions/' + functionName,
        entryPoint: functionName,
        httpsTrigger: {}
      },
      location: 'projects/' + projectName + '/locations/' + functionLocation
    };

    var updateRequest = {
      name: 'projects/' + projectName + '/locations/' + functionLocation +
          '/functions/' + functionName,
      resource: {
        sourceArchiveUrl: 'gs://' + stageBucket + '/' + archiveName,
        name: 'projects/' + projectName + '/locations/' + functionLocation +
            '/functions/' + functionName,
        entryPoint: functionName,
        httpsTrigger: {}
      }
    };

    // Make an authorized request for cloud computing
    // Create a new function
    gcf.projects.locations.functions.create(createRequest, function (err, resp) {
      if (err != null && err.errors[0].reason === 'alreadyExists') {
        // If the function already exists, update it
        gcf.projects.locations.functions.update(
            updateRequest, function (err1, resp1) {
              if (err1) {
                console.log(
                    'Error in updating the %s function: %s', functionName, err);
              } else {
                console.log(
                    'Updating success  of the %s function', functionName);
                res.status(200).send('Function successfuly updated\n');
              }
            });
      } else if (err == null) {
        console.log('Success creating the %s function', functionName);
        res.status(200).send('Function successfuly created\n');
      }
    });
  });
}

/**
 * Validates the request.
 * See https://developer.github.com/webhooks/securing.
 *
 * @param {object} req
 */
function validateRequest (req) {
  return Promise.resolve()
    .then(() => {
      const digest = crypto
        .createHmac('sha1', config.secretToken)
        .update(JSON.stringify(req.body))
        .digest('hex');

      if (req.headers['x-hub-signature'] !== `sha1=${digest}`) {
        const error = new Error('Unauthorized');
        error.statusCode = 403;
        throw error;
      } else {
        console.log('Request validated.');
      }
    });
}

/** The entire proceess starting from cloning the repository and ending with
 * deploying the function.
 *
 * @param {Object} req Cloud Function request context.
 * @param {Object} res Cloud Function response context.
 */
exports.deployHttp = function deployHttp (req, res) {
  /*
   * Parse the request in order to get the required information.
   *
   *   repoName: The name of the github repository. E.g. 'myRepository'
   *   user: The name of the github user. E.g. 'user1'
   *   filePath: The path to the directoty wich contains the function that has
   * to be deployed.
   */
  var obj = JSON.parse(JSON.stringify(req.body));
  var filePath = 'tmp/' + obj.repository.name;
  validateRequest(req);

  downloadRepo(filePath, obj, res);
};

